# UVM SPI

This repository contains an interactive and explanatory verification environment in UVM (Universal Verification Methodology) based on an SPI protocol block. The goal of this project is to provide a simple, yet well-documented platform that can be used to learn and understand the fundamental concepts of UVM and SPI.

## What is UVM?

**UVM (Universal Verification Methodology)** is a standardized methodology for verifying digital designs and systems-on-chip (SoCs) in the semiconductor industry. UVM is built on top of the SystemVerilog language, providing a framework for creating modular, reusable testbench components that can be easily integrated into the design verification process. It also includes a set of guidelines and best practices for developing testbenches, as well as a methodology for running simulations and analyzing results.

UVM has become the de facto standard for design verification in the semiconductor industry, widely adopted by chip designers and verification engineers to ensure the correctness and functionality of their designs.

### What does UVM contain?

UVM contains a set of pre-defined classes and methods that enable users to create modular, reusable testbench components for verifying digital designs and systems-on-chip (SoCs). Some of the key components of UVM include:

1. **Testbench Components**: 
   UVM provides a set of base classes that can be extended to create various testbench components, such as drivers, monitors, scoreboards, and agents. A typical verification environment is built by extending these UVM classes (denoted by the `uvm_*` prefix). These components come with necessary code to connect to each other, handle data packets, and work synchronously.
   
   ![UVM Structure](https://chipverify.com/images/uvm/uvm-tb.gif)
   *Example UVM structure* - *(Image source: ChipVerify)*
   

2. **Transactions**: 
   Transactions model the communication between the design-under-test (DUT) and the testbench. UVM provides a transaction class that can be extended to create transaction objects, which carry information between the DUT and the testbench.

3. **Phases**: 
   UVM defines a set of simulation phases that allow users to control the order in which testbench components are created, initialized, and executed. These phases ensure the simulation runs in a systematic manner.

4. **Messaging and Reporting**: 
   UVM provides a messaging and reporting infrastructure that enables users to output simulation information, such as warnings, errors, and debug data. This helps in tracking the progress and status of the verification process.

5. **Configuration**: 
   The UVM configuration database allows users to store and retrieve configuration information for testbench components, providing flexibility in how components are parameterized.

6. **Functional Coverage**: 
   UVM includes a mechanism for tracking functional coverage, ensuring that the design has been thoroughly tested by monitoring which portions of the design have been exercised during simulation.

7. **Register Abstraction Layer (RAL)**: 
   UVM offers a register abstraction layer that simplifies the process of creating and accessing register maps, which is especially useful for verifying SoCs.

UVM undergoes revisions where new features are added and older ones are sometimes deprecated. The reference manual for UVM can be obtained [here](https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/index.html) and contains a description of the class hierarchy, functions, and tasks. Although UVM has an extensive API, making it overwhelming for new users, it is designed to be learned part by part. A disciplined approach will help users become proficient in understanding and using UVM effectively.

## What is SPI?

**SPI (Serial Peripheral Interface)** is a widely used serial communication protocol for communication between microcontrollers and peripherals such as sensors, displays, and other hardware devices. It uses a master-slave communication model with data transfer in series, making it easy to connect devices using a limited number of wires.

### What does SPI contain?

1. **Communication Lines**:
   - **MISO (Master In Slave Out)**: The line used to send data from the slave device to the master.
   - **MOSI (Master Out Slave In)**: The line used to send data from the master to the slave.
   - **SCK (Serial Clock)**: The clock line generated by the master to synchronize data transfer.
   - **SS (Slave Select)**: The line used to select the active slave device.

2. **Operating Mode**: SPI can operate in different modes depending on the clock polarity and phase configuration (CPOL and CPHA), which affects when data is read and written.

3. **SPI Transactions**: SPI performs data transfers in packet format, which are sent based on the clock signal.

## Project Structure

This repository contains a basic implementation of the SPI protocol in UVM. Each class and component is well-documented, providing a step-by-step guide for learning how to use UVM in the verification of an SPI protocol block.
